#!/bin/bash


#https://www.baeldung.com/linux/use-command-line-arguments-in-bash-script

# define the flags used for run time parameters checking
upper_flag=false
numbers_flag=false


# Loop all parameters use $@
for i in "$@" ; do
    if [ "$i" == "-u" ]; then
        upper_flag=true;
    fi

#   use regex to check -n {{ value }}, this regex only accept numbers
    re='^[0-9]+$'
    if [[ "$i" =~ ${re} ]]; then
          numbers_arg=$i
    fi

#   the reason of using two checking are due to in some conditions -n is not in parameters list {$@}
    if [[ "$(echo "$0 $1" | grep -E -c '\-n')" -eq 1 ]] || [[ "$(echo "$@" | grep -E -c '\-n')" -eq 1 ]]; then
          numbers_flag=true;
    fi
done

# get input from << EOF line by line
while read -r INPUT_STRING;
do

# if parameters include -n and -u {{ value }} then call create_pattern with the same parameters which will generate upper offset
  if [ "$upper_flag" == true ] && [ "$numbers_flag" == true ]; then

     echo "$INPUT_STRING" | tr '[a-z]' '[A-Z]' | tr '[A-Z]' "$(./create_pattern -n "${numbers_arg}" -u)"

# lower offset
  elif [ $numbers_flag == true ]; then

      echo "$INPUT_STRING" | tr '[a-z]' '[A-Z]' | tr '[A-Z]' "$(./create_pattern -n "${numbers_arg}")"
  fi

done
